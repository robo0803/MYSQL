# INDEX
- 검색을 빠르게 하기 위한 자료구조(주로 B트리 계열)
  레코드 추가 / 수정/ 삭제 시 해당 컬럼으로 다시 정렬한 후 검색에 필요한 값들을 미리 계산해 검색 속도를 높임
  
- 기본키는 자동으로 인덱스 설정
- 인덱스 on/off를 통해 검색속도 차이 체감
- 조인시에도 영향을 줌

예시 
create index B_Name_index on B(Name); // index 생성
show create table B; // index 추가된것 확인
alter table B drop index B_Name_index; // index 삭제

# 메타데이터
- 데이터를 위한 데이터
- DB, 테이블의 스키마에 대한 정보를 저장하는 테이블

## 데이터 사전 
- 데이터베이스의 정보 저장
- 시스템 카탈로그라고 함
- 읽기전용정보

## 데이터 디렉토리
- dbms의 모든 데이터가 저장되는 디렉토리(폴더)
- db저장, 상태 및 로그저장

# 캐릭터셋/콜레이션

### 캐릭터셋

- 문자인코딩 정보/ 메타데이터의 일종
- 문자열의 값을 저장할 때 사용되는 기본정보
- DB/테이블별로 별도 설정 가능

### collation
- 데이터를 정렬할 때 사용하는 정보
- 정렬 시에 대소문자를 구분/비구분여부 설정 => utf8-unicode-ci
- 한글데이터의 경우 무의미

# 스토리지 엔진(storage engine)
- dbms가 데이터를 crud할때 사용하는 기본 컴포넌트
- 대표적으로 myisam 과 innodb가 있음
- 데이터 접근속도 / 안정성/ 트랜잭션의 지원 여부등의 차이가 있음
- InnoDB : 트랜잭션 지원/업데이트 위주/줄단위 락/복구용이/동시처리성능 높임
- MyISAm : 상대적으로 높은 성능/읽기 위주/ 테이블단위 락

# 데이터베이스 백업

### 전체 db 백업
mysqldump-u아이디-p--all-databases > 덤프파일명.sql

### 특정 db 백업
mysqldump-u아이디-p--databases DB명 > 덤프파일명.sql

### 특정 테이블 백업
mysqldump-u아이디-p DB명 테이블명 > 덤프파일명.sql

### 스키마만 백업
mysqldump-u아이디-p--no-data 

### 데이터만 백업
mysqldump-u아이디-p--no-create-info

### db 백업(workbench에서)
- DataExport->Export Options -> Export to Self-Containde File
- Tables to Export
- 테이블 선택
- Dump Structure and DAta/Structure Only/Data only
- Export 버튼

# 데이터베이스 복원
### 콘솔
- mysql-u아이디-p DB명 < 파일명
- mysql-u아이디-p < 파일명
- mysql-u아이디-p DB명 테이블명 < 파일명

### 프롬프트
- SQL > source 파일명

# 데이터베이스 로그 : 데이터베이스 운영 상황을 별도의 파일에 저장

### 에러로그
- mysql 구동과 모니터링, query 에러에 관련된 메시지를 포함

### 일반로그
- 전체 쿼리에 대하여 general log 를 활성화 시켜서 저장 가능

### 슬로우 쿼리 로그
- long_query_tiem 에 설정된 시간 이상을 소요한 쿼리를 기록

### 이진 로그 / 릴레이 로그
- mysql 쿼리를 수행하면서 쌓는 로그, 시점 복구 등을 수행하는 역할
- Replication 에서 사용
- 바이너리 로그 / 릴레이 로그에서 사용, 내용동일

# 파티셔닝 / 샤딩
## 데이터베이스 파티셔닝
### VLDB(Very Large DBMS)
- 전체 DB가 하나의 DBMS시스템에 다 들어가기 힘들어지는 경우 
- 테이블 들을 여러 개의 군으로 나눠 분산 저장
- 하나의 테이블이 방대한 경우에는 사전방식과 같이 나눠 저장

### 파티셔닝
- DBMS 레벨 분할

### 샤딩(Sharding)
- DBMS 외부에서 분할 / 응용레벨에서 구별해야 함

### 제약사항
- 테이블단위 연산이 힘들어짐(비용문제)
- 조인연산 어려움 -> 정규화 문제
- 역정규화 -> 중복허용으로 해결
================================================
* 외래키의 효용문제
- 레코드 추가 시 참조무결성 조건 체크 -> 시스템 부담증가로 수동전환
- CRUD 시 위치를 인식해야 함(파티셔닝/샤딩이 다름)

### 이점
- 데이터 전체 검색 시 필요한 부분만 탐색해 성능 증가
- 전체 데이터를 손실할 가능성 줄어듦 -> 가용성 향상
- 파티션별 백업/복구 가능
- 파티션 단위로 I/O 분산가능 -> 업데이트 성능 증가

### 파티셔닝 방식
- 범위 a-m / n-r / s-z
- 해시 : 해시함수 파티션별로 크기를 비슷하게 나눔
- 리스트 : 특정한 컬럼을 기준
- 컴포지트 : range-hash / range-list
- 외래키 / full text 인덱스 지원 안함
- 파티션 값은 정수

# 데이터 베이스 복제
- dbms의 내용을 복제해 동일한 db내용을 유지
- 두 개 이상의 dbms 시스템을 마스터/슬레이브로 나눠 마스터 dbms-> 슬레이브 dbms로 sql쿼리 복제
    - 데이터 업데이트는 마스터에서
    - 읽기는 슬레이브에서
- 읽기 성능 향상
- 웹서버 시스템 성능확장에 적합

### 로그기반 복제
- statement based : sql문장복제, sql에 따라 결과가 달라지는 경우
- row based : sql에 따라 변경된 라인만 기록하는 방식 / 데이터가 많이 변경된 경우 데이터 커짐
- mixed : 두 방식 복합


